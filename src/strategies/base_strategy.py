"""
Base Strategy Interface

Defines the common interface and utilities for all trading strategies.
Each strategy must implement the evaluate() method to generate trading signals.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import time

from src.utils.logger import get_logger

logger = get_logger(__name__)


@dataclass
class TradingSignal:
    """
    Represents a trading signal generated by a strategy.

    Contains all information needed to execute a trade.
    """
    # Required fields
    market_id: str  # Polymarket condition ID
    token_id: str  # Token to trade
    outcome: str  # "Yes" or "No"
    size: float  # Position size in USDC
    price: float  # Target price

    # Signal quality
    ev: float  # Expected value (0.02 = 2% expected profit)
    confidence: float  # Strategy confidence (0-1)

    # Metadata
    strategy: str  # Strategy name
    reason: str  # Human-readable reason for signal
    timestamp: float  # Signal generation time

    # Optional
    urgency: str = "normal"  # "high", "normal", "low"
    max_slippage: float = 0.01  # Maximum acceptable slippage
    time_horizon_seconds: int = 900  # Expected holding time

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for processing."""
        return {
            "market_id": self.market_id,
            "token_id": self.token_id,
            "outcome": self.outcome,
            "size": self.size,
            "price": self.price,
            "ev": self.ev,
            "confidence": self.confidence,
            "strategy": self.strategy,
            "reason": self.reason,
            "timestamp": self.timestamp,
            "urgency": self.urgency,
            "max_slippage": self.max_slippage,
            "time_horizon_seconds": self.time_horizon_seconds,
        }


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    All strategies must implement:
    - evaluate(): Generate trading signals based on market data

    Provides common utilities:
    - EV calculation with fees
    - Position sizing
    - Signal creation
    - Logging
    """

    # Fee structure (post-2026)
    TAKER_FEE = 0.03  # 3% taker fee
    MAKER_REBATE = 0.01  # 1% maker rebate (varies by phase)

    def __init__(
        self,
        name: str,
        config: Optional[Dict[str, Any]] = None,
    ):
        """
        Initialize base strategy.

        Args:
            name: Strategy name for logging
            config: Strategy-specific configuration
        """
        self.name = name
        self.config = config or {}
        self._enabled = True
        self._last_evaluation = 0
        self._signals_generated = 0
        self._signals_executed = 0

        logger.info(f"Strategy initialized: {name}")

    @abstractmethod
    def evaluate(
        self,
        markets: List[Any],
        positions: List[Any],
        balance: float,
    ) -> List[Dict[str, Any]]:
        """
        Evaluate markets and generate trading signals.

        Args:
            markets: List of Market objects from Polymarket
            positions: Current open positions
            balance: Available balance in USDC

        Returns:
            List of trading signal dicts
        """
        pass

    def calculate_ev(
        self,
        fair_value: float,
        price: float,
        is_maker: bool = True,
    ) -> float:
        """
        Calculate expected value of a trade.

        EV = (fair_value - price) - fees/rebates

        For maker orders, we earn rebates, improving EV.
        For taker orders, we pay fees, reducing EV.

        Args:
            fair_value: Estimated true probability
            price: Price we would pay
            is_maker: Whether this is a maker order

        Returns:
            Expected value as decimal (0.02 = 2%)
        """
        # Raw edge
        edge = fair_value - price

        # Apply fee impact
        if is_maker:
            # Maker earns rebate
            fee_impact = self.MAKER_REBATE
        else:
            # Taker pays fee
            fee_impact = -self.TAKER_FEE

        ev = edge + fee_impact

        return ev

    def calculate_position_size(
        self,
        ev: float,
        balance: float,
        confidence: float = 1.0,
        max_position_pct: float = 0.02,
    ) -> float:
        """
        Calculate appropriate position size based on EV and risk.

        Uses a conservative fraction of Kelly criterion:
        - Full Kelly can be aggressive
        - We use 25% Kelly for safety
        - Additional confidence discount

        For $50 starting capital, this typically results in
        $0.50-$2.00 position sizes.

        Args:
            ev: Expected value
            balance: Current balance
            confidence: Strategy confidence (0-1)
            max_position_pct: Maximum position as % of balance

        Returns:
            Position size in USDC
        """
        if ev <= 0:
            return 0

        # Kelly fraction
        kelly_fraction = 0.25

        # Calculate raw size
        raw_size = balance * ev * kelly_fraction * confidence

        # Apply max limit
        max_size = balance * max_position_pct

        # Minimum size
        min_size = 0.50

        size = max(min_size, min(raw_size, max_size))

        return round(size, 2)

    def create_signal(
        self,
        market_id: str,
        token_id: str,
        outcome: str,
        price: float,
        ev: float,
        confidence: float,
        reason: str,
        balance: float,
        **kwargs,
    ) -> TradingSignal:
        """
        Create a standardized trading signal.

        Args:
            market_id: Market condition ID
            token_id: Token to trade
            outcome: "Yes" or "No"
            price: Target entry price
            ev: Expected value
            confidence: Strategy confidence
            reason: Reason for the signal
            balance: Available balance for sizing
            **kwargs: Additional signal parameters

        Returns:
            TradingSignal object
        """
        # Calculate position size
        size = self.calculate_position_size(
            ev=ev,
            balance=balance,
            confidence=confidence,
            max_position_pct=self.config.get("max_position_percent", 0.02),
        )

        # Override size if provided
        if "size" in kwargs:
            size = min(kwargs.pop("size"), size)

        signal = TradingSignal(
            market_id=market_id,
            token_id=token_id,
            outcome=outcome,
            size=size,
            price=price,
            ev=ev,
            confidence=confidence,
            strategy=self.name,
            reason=reason,
            timestamp=time.time(),
            **kwargs,
        )

        self._signals_generated += 1

        logger.info(
            f"[{self.name}] Signal: {outcome} ${size:.2f} @ {price:.4f} "
            f"(EV={ev:.3f}, reason={reason})"
        )

        return signal

    def filter_markets(
        self,
        markets: List[Any],
        min_liquidity: float = 100,
        categories: Optional[List[str]] = None,
        max_hours_to_resolution: float = 24,
    ) -> List[Any]:
        """
        Filter markets based on criteria.

        Args:
            markets: List of markets to filter
            min_liquidity: Minimum liquidity requirement
            categories: Allowed categories (None = all)
            max_hours_to_resolution: Maximum time until resolution

        Returns:
            Filtered list of markets
        """
        filtered = []

        for market in markets:
            # Check liquidity
            if market.liquidity < min_liquidity:
                continue

            # Check category
            if categories and market.category not in categories:
                continue

            # Check active
            if not market.active:
                continue

            filtered.append(market)

        return filtered

    def get_opposing_outcome(self, outcome: str) -> str:
        """Get the opposing outcome for binary markets."""
        return "No" if outcome == "Yes" else "Yes"

    def is_enabled(self) -> bool:
        """Check if strategy is enabled."""
        return self._enabled

    def enable(self) -> None:
        """Enable the strategy."""
        self._enabled = True
        logger.info(f"Strategy enabled: {self.name}")

    def disable(self) -> None:
        """Disable the strategy."""
        self._enabled = False
        logger.info(f"Strategy disabled: {self.name}")

    def get_stats(self) -> Dict[str, Any]:
        """Get strategy statistics."""
        return {
            "name": self.name,
            "enabled": self._enabled,
            "signals_generated": self._signals_generated,
            "signals_executed": self._signals_executed,
            "last_evaluation": self._last_evaluation,
        }
